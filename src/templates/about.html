<div class="flex flex-col gap-4">
    <div class="text-3xl text-center font-bold">Как это работает. Алгоритм Левенштейна</div>
    <p class="text-justify"><strong>Расстояние Левенштейна</strong> (редакционное расстояние, дистанция редактирования) — метрика, измеряющая по модулю разность между двумя последовательностями символов. Она определяется как минимальное количество односимвольных операций (а именно вставки, удаления, замены), необходимых для превращения одной последовательности символов в другую. В общем случае, операциям, используемым в этом преобразовании, можно назначить разные цены. Широко используется в теории информации и компьютерной лингвистике. Впервые задачу поставил в 1965 году советский математик Владимир Левенштейн при изучении последовательностей 0-1, впоследствии более общую задачу для произвольного алфавита связали с его именем. Большой вклад в изучение вопроса внёс Дэн Гасфилд.</p>
    <p class="text-justify">Расстояние Левенштейна и его обобщения активно применяется:</p>
    <ul class="list-disc px-4 mx-4">
        <li class="text-justify">для исправления ошибок в слове (в поисковых системах, базах данных, при вводе текста, при автоматическом распознавании отсканированного текста или речи).</li>
        <li class="text-justify">для сравнения текстовых файлов утилитой diff и ей подобными. Здесь роль «символов» играют строки, а роль «строк» — файлы.</li>
        <li class="text-justify">в биоинформатике для сравнения генов, хромосом и белков.</li>
    </ul>
    <p class="text-justify">С точки зрения приложений определение расстояния между словами или текстовыми полями по Левенштейну обладает следующими недостатками:</p>
    <ul class="list-decimal px-4 mx-4">
        <li class="text-justify">При перестановке местами слов или частей слов получаются сравнительно большие расстояния;</li>
        <li class="text-justify">Расстояния между совершенно разными короткими словами оказываются небольшими, в то время как расстояния между очень похожими длинными словами оказываются значительными.</li>
    </ul>
    <p class="text-justify">
        Здесь и далее считается, что элементы строк нумеруются с первого, как принято в математике, а не с нулевого, как принято во многих языках программирования. <br>
        Пусть S1 и S2 - две строки (длиной M и N соответственно) над некоторым алфавитом, тогда редакционное расстояние (расстояние Левенштейна) d(S1,S2) можно подсчитать по следующей рекуррентной формуле d(S1,S2) = D(M,N), где        
    </p>
    <div class="flex flex-col w-full items-center">
        <img src="/static/formula.svg" class="w-[50%]" alt="formula">
    </div>
    <p class="text-justify">где m(a,b) равна нулю, если a = b и единице в противном случае; min{a,b,c} возвращает наименьший из аргументов.</p>
    <p class="text-justify">Здесь шаг по i символизирует удаление (D) из первой строки, по j — вставку (I) в первую строку, а шаг по обоим индексам символизирует замену символа (R) или отсутствие изменений (M).</p>
    <p class="text-justify">Очевидно, справедливы следующие утверждения:</p>
    <div class="flex flex-col w-full items-center">
        <img src="/static/pravila.png" class="w-[50%]" alt="formula">
    </div>
    <div class="flex flex-col w-full items-center">
        <img src="/static/primer.png" class="w-[50%]" alt="formula">
    </div>
    <p class="text-justify">В правой нижней клетке матрицы находится необходимое количество правок, что бы превратить строку А (POLYNOMINAL) в строку B (EXPONENTIAL). Используя этот алгоритм, можно создать функцию приблизительного поиска субстроки в тексте. Проверив каждое слово в тексте, можно составить рейтинг слов, который позже, отсортировав от минимального к максимальному, можно предоставить пользователю.</p>
    <p class="text-justify">На практике, это означает создание функции поиска, в которой пользователь вводит строку которая содержит ошибки или опечатки. Алгоритм точного поиска в таком случае невозможен, поскольку введенные данные изначально ошибочны. Алгоритм приблизительного поиска же найдет слово с минимальным расстоянием Левенштейна и предоставит его в качестве результата. Таким образом, пользователь, ищущий в тексте слово <strong>"дерефо"</strong> увидет результаты, содержащие слово <strong>"дерево"</strong>.</p>
</div>